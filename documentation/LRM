**make everything mutable (including endpoints and fields but no record structure), 
no heterogeneity-- define a graph with a node structure in there already**

1. Introduction

This manual describes GRAIL, a language optimized for building and performing computations on graphs. The syntax is streamlined to facilitate easily constructing, accessing, searching, and modifying graphs, nodes, and edges.

2. Tokens

GRAIL tokens are separated by one or more whitespace characters. Comments delimited by /* and */ or single-line comments beginning with // are also ignored. Comments may not be nested.

2.1. Identifiers

An identifier is a sequence of characters, all of which must be either alphanumeric or the underscore (_) character. The first character must be a letter. Uppercase and lowercase letters are considered distinct but the choice of case in identifiers holds no significance to the compiler.

2.2. Reserved Words

The following identifiers are reserved and may not be used elsewhere: 

accio, boolean, break, char, display, double, edge, else, empty, false, for, free, from, graph, if, in, int, node, print, record, return, size, sort, string, to, true, type, void, while, with

2.2.5. User-defined Keywords

User-definable keywords appear in records and nodes, and can be any string of one or more alphanumeric characters. (Up to 32 chars).

2.3. Constants

Integers, denoted int, are a 32 bit sequence of digits with no floating point.

Double, denoted double, is a 64 bit floating point number.

Characters, denoted char, are single characters enclosed by single quotation marks.

Boolean constants (boolean) are represented by the keywords true and false. Booleans may take on only these two values and void (and the last only on initialization).

String literals (string) are a series of characters delimited by double quotation marks. Strings cannot be nested, though a double quotation mark can appear inside a string by using the escape sequence \”.

3. Types
3.1. Primitive Types

GRAIL has 5 primitive types: boolean, char, int, double, and void. A boolean is a Boolean value. A char is a single member of the ASCII character set. (More complex character sets are not supported.) An int is an integer. A double is a floating point number. The void type is a null type, used in functions that return no variables and uninitialized primitives.

3.2. Derived types

Records are user-defineable data-structure consisting of comma-separated pairs of keys (which must be unique within the record) and data. The data may be any primitive or derived type. Nodes can be used as records, but only specially formatted records can be used as nodes.

Nodes are objects containing a key* and a record. They are referred to by their keys and can be connected by edges to other nodes.

Lists are arrays of primitives or objects of the same type. The type of a list has the type of the first element inserted into a list. If all the elements of a list are removed, it maintains its type.

Edge descriptor. 
An edge descriptor connects two nodes and can be directed or undirected, but contains no records. It is what you get when you declare an edge without a with field and irrespective of a graph:

e = u->v; //where u and v are nodes.

This is a way of defining edges before you know the record, and adding the relation (and nodes) to different graphs.

**It's not exactly primitive-- edge descriptors really contain copies of their nodes. However, when they're added to graphs that already contain nodes with the same keywords, they either throw up an error (if the nodes are different objects), or add the edge between the already present nodes. 
(It would be more primitive if we only allowed adding edge relations when the nodes already exist in the graph but that would wreak havoc with our constructor syntax. Clear and less error prone or needlessly annoying?)**

Edge. An edge consists of an edge descriptor and a record. The record's structure (including field types) may not be altered, though its fields may be changed. An edge always has "hidden" to, from, and rel fields.

**what about undirected edges? What should to/from return?**

Graphs are collections of nodes (uniquely identified by keywords) and the edges connecting them (uniquely identified by their endpoints and direction), with default edge fields defined. Edge fields on a graph cannot be updated, but the relations or edges can be copied to another graph.

**what if you wanted to take an edge, extract its record, change it, and put that in a different edge?**

Strings are arrays of chars. While strings are stored internally as arrays, they act similarly to primitive types, as they can be declared with the keyword string and can be nodes of graphs.

4. Objects and LValues
An object is a named region of storage; an lvalue is an expression referring to an object. An obvious example of an lvalue expression is an identifier with suitable type and storage class. The name ``lvalue'' comes from the assignment expression E1 = E2 in which the left operand E1 must be an lvalue expression. 

Examples:
my_list = ["Bob", "Diane", "Agnes"];												//list
my_record = {age:6, weight:15, size:{height:65, head:"big"}, children:my_list};		//record
my_node = {eleven:my_record};														//node
my_node = {7:{seen:[4,5,2]}};
your_node = {8:{age:5, change:"were"}};				
my_fields = {weight:7, capacity:5, street:"Dawson"};									//record
my_graph = (my_node, your_node, his_node, her_node, my_node -> your_node, his_node <- her_node, her_node -- my_node) with my_fields
your_graph = () with {weight:1, capacity:1, street:""}
my_graph = () with fields
his_graph = 
my_edge_desc = 	my_node -> your_node												//an edge descriptor
my_edge = my_node -> your_node with {weight:1, capacity:1, street:""};				//an edge
my_edge2 = her_node -> his_node with fields;

my_int = 3; 																			//int
my_double = 3.0;																		//double
g = (e, f, g) with {weight:1} 
//where e, f, and g are edges, edge descriptors, or nodes of the same type. The field after with is the default edge record

5. Expressions
Expressions, consisting of type-compatible operators or groups of operators separated by operands, are outlined below in descending order of precedence.

5.1. Subset Operators:

Graphs:
my_node = my_graph["key"];  //access a node by its keyword
my_edge = my_graph[node1 -> node2]; //access the edge between the keys of those nodes.
my_nodes = my_graph[x : x in [u, v, w]]; //access a list of nodes
my_nodes = my_graph[x : x.key in ["first", "second", "third"]]; //access a list of nodes by key
my_edges = my_graph[x -- y: x in my_list && y == "my_key"]; //access a list of edges that match the condition/s. If no conditions are supplied, yields all edges.

**Currently-- no way to access edges by edge fields**

Records:
my_field = my_record["name_of_field"];

Edges:
my_weight = my_edge["weight"]; //access a feature in an edge
b = "weight";				   //or
my_child = my_edge[b];

Nodes:
my_street = my_node["street"];		//gets a feature of the node.

**what about --? Two nodes in both directions. Do we need <> notation to make sure we get it? It would distinguish between only undirected edges and both. **
**Also begs the question can you do my_node.graph = h; And the answer is no.**

Lists:
entry = list[0];				//can be accessed by 

5.15. Dot Operator: Access fields of a record, or nodes of a graph
(*WIP
my_node = my_graph.nodes["cheese"];						//access a node by its keyword
my_edge = mygraph.edges 						//what if this is an edge, not an edge descriptor?
my_int = my_graph.cheese.; 
my_edge_rel = my_edge.rel; 						//to get 2--3 out of an edge. Especially important for undirected.
my_edge_rec = my_edge*;							//We had to get the * somewhere. This grabs the record out of the edge, 

sans hidden to/from/rel fields. **should we have the same thing for nodes? yes because the node might have more than the user-defined record?**

Nodes:
my_graph = my_node.graph;			//A node can only be in one graph at once.
my_friends = my_node.graph[x<>y:x == my_node]	//one (ugly) way to get all the neighbors of a node.
my_friends = my_node.friends		//syntactic shorthand for this. No graph? No luck, buddy.
my_friends = my_node.to 			//Everything going to my_node. 
my_friends = my_node.from 			//Everything going from my node
*)

**danger of silently returning a list instead of a single node or edge...**

5.2. Unary Operators:
expr* (edge) Yields the edge descriptor of the edge, without the record.
!expr  (booleans, boolean expr) Logical not. Yields the opposite value of the expression.
-expr (num) Numeric negation. Yields the expression multiplied by negative one.

5.3. Numeric Binary Operators
Binary operators group left to right. 

expr * expr (int, double) Multiplication operator.
expr / expr (int, double) Division operator.

expr + expr (int, double) Addition operator.
expr - expr (int, double) Subtraction operator.

5.3.5 Graph, Edge, and Node Operators
graph + node Yields a graph with the node added
graph + edge Yields a graph with the edge added (if the edge is not already in the graph)

5.4. Relational Operators
expr < expr (int, double, string), less than
expr > expr (int, double, string), greater than
expr <= expr (int, double, string), less than or equal to
expr >= expr (int, double, string), greater than or equal to
Return true if the relation is true and false otherwise

5.5. Equality Operators
expr == expr (int, double, string) returns true if the numbers are equal, and false otherwise
expr != expr (int, double, string) returns false if the numbers are equal, and true otherwise 

expr == expr (graph) returns true if both graphs contain the same nodes and edges

5.6. Logical Operators
expr && expr (boolean), returns true if both booleans or boolean expressions are true and false otherwise
expr || expr (boolean), returns true if at least one of the booleans or boolean expressions is true and false otherwise

5.7. Assignment
lvalue = expr, replaces the value of the lvalue with the value of the expr, if they are the same type
5.7 Edge Descriptor
node -- node yields an edge connecting both nodes. The operator can be --, ->, <-

5.8. Edge Operators
node -- node with record, yields an edge connecting both expr’s (num, char, or string), with the fields set according to the record.
node -> node with record, yields directed edge from the first expr (num, char, or string), with the fields set according to the record.
node <- node with record, yields directed edge from the second expr (num, char, or string), with the fields set according to the record.


6. Declarations
Declaration defines and specifies the properties of an identifier in a structured format. 

6.1 Type specifiers:
The type-specifiers in our language are:
void
char
string
int
double
node
edge 
graph 
list 

These type specifiers define the type of the variables, parameters, and function return types. Void is only allowed in the function return type.  

6.3 Function Declarator
The Function declarator is formatted in the following way:
	functionName(param, param, … )

FunctionName is the identifier of the function, followed by a left parenthesis, a list of function parameters(optional), and a right parenthesis. In the function parameter list, these parameters need to be separated by commas. 

6.4 Initialization
The general format of the initialization of variables is:
	variableName = assignment expression / { list of edges or edge-relations }

	Primitives:
	variableName = value;

	Records: //Records have literal declaration:
	accio(space);		//or something
	myRecord = {field1:val1, field2:val2...};

	Nodes:
	accio(space);
	myNode = {key:myrecord};

	Edge-Descriptor:
	mydesc = node -> node;
	mydesc = node <- node;
	mydesc = node -- node;	//undirected edge is technically two edges, one in each direction, with the same record

	Edges:
	accio(space);
	myEdge = edge_desc with myrecord;
	
	Graph:	//a graph can take any number of edges and nodes or lists of edges and nodes
	accio(space);
	graph = {edge, node, … } with myrecord | {list of edges} with myrecord
	
The following examples shows the declaration and initialization of graphs and nodes:

g = (1->2,2->3,3->4) with {weight:1};
g = (2->3 with {weight:2, capacity:7}) with {weight:1, capacity:8};
//or
g = (2->3 {2,7}) with {weight:1, capacity:8};

g += u -> v; //add an edge between u and v with weight:1
g += n -- m with {weight:7}  //add an edge with a different record;
g += o -- p with {weight:7, capacity:6} //illegal! Error!
g += a;		//adds the node to the node list of g.

//what about adding something already in the graph? If it's a relation it'll stay, if it's an edge it'll throw up an error? You'll have to fetch the edge yourself and change its fields? 

6.5 Update
Edges:
	e = 2--3 with {weight:4, height:7};	//initialize
	e.rel = 4--3;						//update edges
	e.to = 5;							//e.rel = 4--5 (does it cause problems to remember which is from and which to?)
	e = e.rel {4,6};					//update the height to 7 **what about e = e.rel {record} ? Do we need a with?**
	e.height = 5;						//update the height to 5.

**we still need a way to grab all the nodes or edges that a node is connected to irrespective of the graph. **

7. Statements
	Statements executes in sequence. They do not have values and are executed for their effects. The statements in our language are classified in the following groups:
Assignment statement
	Function-call statement
	Sequence statement
	Control-Flow statement
	Loop Statement
	Jump Statement
	

7.1 Assignment Statement 
Assignment statement is used to assign identifier with the value of the expression. It is formatted in the following format:
	identifierName = expression;
This statement is commonly used for initialization of variables or expressions. 

7.2 Function-Call Statement 
The function-call statement is used when a defined function is called. It is formatted in the following format. Parameters can be any of the primitive types or objects or expressions that evaluate to those types or objects.

type functionName (parameter, parameter, ...);


7.3 Sequence Statement 
Statements can be written one after another. This is seen as the sequence statement and is formatted in the following format:
	statement; statement; statement; …


7.4 Control-Flow Statement
The control-flow statements use the expression as conditional test to decide which block of statements will get executed. They have the following formats:
if (expression) { statement(s) }
if (expression) { statement(s) } else { statement(s) }
if (expression) { statement(s) } else if (expression) { statement(s) } else { statement(s) }


7.5 Loop Statement
while loop and for loop are available in the GRAIL in the following format:

while (expression) { statement(s) }
for (initialization expression; conditional expression; execution expression ) { statement(s) }

The while loop takes one expression as the conditional expression to check if the available variables or expressions qualify, which determine if the body statement(s) will be executed or not. The for loop takes three expressions : initialization expression, conditional expression, and execution expression. The initialization expression will be executed when the for loop is initiated. The conditional expression is the test expression to check if the condition(s) is satisfied, which corresponds to if the body statement(s) will be executed. The execution expression will be executed after every time the body statement(s) is executed. 

7.6 Jump Statement
break can be used to break the first outer loop if a certain condition is reached. 
	for (expression; expression; expression) {
		…
		if (expression) {
			break;
		}
		....
	}

continue can be used to continue to the next round of the loop if a certain condition is reached. 
	while (expression) {
		…
		if (expression) {
			continue;
		}
		....
	}

8. Scope
A declared entity is a class type, member (class, field, or function) of a reference type, type parameter (of a class, function or constructor), parameter (to a function, constructor), or local variable.
Every declaration that introduces a name has a scope, which is the part of the program text within which the declared entity can be referred to by a simple name.
The scope of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name. 
A declaration is said to be in scope at a particular point in a program if and only if the declaration's scope includes that point.
The scope of a formal parameter of a function or constructor is the entire body of the function or constructor. 
The scope of a function's type parameter  is the entire declaration of the function, including the type parameter section, but excluding the function modifiers. 

9. Library Functions
9.1 Print 
Prints strings to standard output. 
	print (list of string statement)

9.2 Display
Function for displaying graphs and digraphs
	display(graph)
	display(digraph)

10. Examples
Sort a list of edges by their weight:
function sort(my_list, feature){
	sort(my_list, 0, size(my_list)-1, feature);
}
function sort(my_list, left, right, feat){
	if(left < right){
		pivot = my_list[right];
		partition = partitionIt(my_list, left, right, pivot, feat);
		sort(my_list, left, partition-1, feat);
		sort(my_list, partition+1, right, feat);
	}
	return my_list;
}
function partitionIt(my_list, left, right, pivot, feat){
	l = left;
	r = right;
	while(l < r){
		while(a[l][feat] < pivot)
			l++;
		while(r > 0 && a[r][feat] > pivot)
			r--;
		if(r <= l)
			break;
		swap(my_list, r, l);
	}
	swap(a, l, right);
	return l;
}
function swap(my_list, left, right){
	temp = my_list[left];
	my_list[left] = my_list[right];
	my_list[right] = temp;
}
function main(){
	f = {"Franklin":{}};
	e = {"Englewood":{region: "24j2ioj"}};
	d = {"Dawson":{region: "523io9852"}};
	mygraph = {e, f, g, f->g, g<-f, f--e} with {weight:1};			//default fields weight:1
	mygraph[f->g].weight = 3;
	mygraph[g<-f].weight = 8;

	mylist = mygraph[x <> y :];
	mylist = sort(my_list, "weight");
}

//Walking through the graph in order? Iterating through all edges, all nodes? Ordering nodes, edges
my_edges = my_graph[x <> y :]	//grab all edges of any type in the graph and place in a list.

The following program implements Djikstra’s Algorithm for finding a shortest path.

list getclosestpaths(graph g, num s){

g.sort(weight, asc);
list dist = [size(g)]; 
list prev= [size(g)];
list visited = [size(g)];

num inf = Grail.Math.INF;

for(num i = 0; i < size(dist); i+=1){
dist[i] = inf;
visited[i] = false;
}
dist[s] = 0;

for(num i = 0; i < size(g); i+=1){
next = closestNode(dist, visited);
visited[next] = true;
neighbors = g[x --> y : x == next]; //Get all nodes from x

for(num j = 0; j < size(neighbors); j+=1){
num n = neighbors[j];
num d = neighbors[j].weight + dist[next];

if(dist[n] > d){
dist[n] = d;
prev[n] = next;
}
}
}
return pred;
}

num closestNode(list dist, list visited){
num d = Grail.Math.INF;
num n;
for(num i = 0; i < size(dist); i++){
if(v[i] == false && dist[i] < d){
n = i;
d = dist[i];
}
}
return n;
}

//initialize a graph, add a node and an edge, and run closest paths algorithm

graph g = {1->2,2->3,3->4};
g* += 5;
g += 4->5;

list allPaths = getClosestPaths(g,1);

11. Recapitulation
GRAIL is possessed of several types, denoted by keywords such as num and 


