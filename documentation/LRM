**make everything mutable (including endpoints and fields but no record structure), 
no heterogeneity--**

1. Introduction

This manual describes GRAIL, a language optimized for building and performing computations on graphs. The syntax is streamlined to facilitate easily constructing, accessing, searching, and modifying graphs, nodes, and edges, as well as representing user-defined data within those constructs.

2. Tokens

GRAIL tokens are separated by one or more whitespace characters. Comments delimited by /* and */ or single-line comments beginning with // are also ignored. Comments may not be nested.

2.1. Identifiers

An identifier is a sequence of characters, all of which must be either alphanumeric or the underscore (_) character. The first character must be a letter. Uppercase and lowercase letters are considered distinct but the choice of case in identifiers holds no significance to the compiler. Identifiers can be used for variables or features of records. (Up to 32 chars).

2.2. Reserved Words

The following identifiers are reserved and may not be used elsewhere: 

accio, break, else, false, for, free, from, if, in, record, return, size, to, true, type, void, while, with

2.3. Constants

Integers are a 32 bit sequence of digits with no floating point:
var = 3;

Double is a 64 bit floating point number:
var = 3.0;

Characters are single characters enclosed by single quotation marks.
var = 'a';

Boolean constants are represented by the keywords true and false. Booleans may take on only these two values.
var = false;

String literals (string) are a series of characters delimited by double quotation marks. Strings cannot be nested, though a double quotation mark can appear inside a string by using the escape sequence \”.

3. Types
3.1. Primitive Types

GRAIL has 5 primitive types: boolean, character, integer, double, and void. A boolean is a true/false Boolean value. A char is a single member of the ASCII character set. An integer is any mathematical integer. A double is a rational non-integer number. The void type is a null type, used in functions that return no variables.

3.2. Derived types
Record:
Records are user-defineable data-structure consisting of comma-separated pairs of keys (which must be unique within the record) and data. The data may be any primitive or derived type. 

Edge Descriptor:
An edge descriptor connects two nodes and can be directed or undirected, but contains no records. It is what you get when you declare an edge without a with field and irrespective of a graph:

e = u->v; //where u and v are nodes.

This is a way of defining edges before you know the record, and adding the relation (and nodes) to different graphs. (Really just an edge with a void record).

It's not exactly a primitive operation-- edge descriptors really contain copies of their nodes. However, when they're added to graphs that already contain nodes with the same keywords, they either throw up an error (if the nodes are different objects), or add the edge between the already present nodes.
	
Edge: 
An edge consists of an edge descriptor and a record. The record's structure (including field types) may not be altered, though its fields may be changed. An edge always has "hidden" to, from, and rel fields that yield the node pointed to by the edge (or the first node in an undirected edge), the node that extends from the edge (or the second node in an undirected edge), and the edge descriptor for the edge respectively.


Nodes:
Nodes can be used as records, but only specially formatted records can be used as nodes. 
**So you can turn a node into an edge:
	node = {mynode:{street:Dawson, trees:100}};
	graph = (u->v, edge2, edge3, node2, node3) with node;
Is that going to screw us over?**

Nodes are objects containing a key and a record. They can be referred to by their keys and connected by edges to other nodes. Nodes in a graph must contain the same record structure (the same field names and types).

Lists:
Lists are arrays of primitives or objects of the same type. The type of a list has the type of the first element inserted into a list. If all the elements of a list are removed, it maintains its type.

Graphs:
Graphs are collections of nodes (uniquely identified by keywords) and the edges connecting them (uniquely identified by their endpoints and direction*), with default edge fields defined. Edge fields on a graph cannot be updated, but the relations or edges can be copied to another graph.

*
  e = node1--node2;
  f = node1->node2;
  g += e;	//good
  g += f;	//error.
*
**
What if you wanted to take an edge, extract its record, change it, and put that in a different edge?
	edge2 .= edge1;	//copy edge1
	edge2.to = u; 	
	edge2.from = v; 
**

Strings are arrays of chars.

5. Expressions
Expressions, consisting of type-compatible operators or groups of operators separated by operands, are outlined below in descending order of precedence.

5.1. Subset Operators:
Graphs:
node = graph.nodes["key"];  									//access a node by its keyword
edge = graph.edges[node1 -> node2]; 							//access the edge between the keys of those nodes.
nodes = graph.nodes[x : x in [u, v, w]];						//access a list of nodes
nodes = graph.nodes[x : x.key in ["first", "second", "third"]]; //access a list of nodes by key
/*access a list of edge-descriptors that match the condition/s. If no conditions are supplied, yields all edges.*/
edgedesc = graph.edges[x -- y: x in my_list && y == "my_key"]; 	//all undirected edge-descriptors
edgedesc = graph.edges[x <> y: x in my_list && y == "my_key"];	//all edges regardless of direction.		
edges = graph.edges[x -e- y : e.school == "Dawson"];			//How to get edges by edge features.
nodes = graph.nodes[x -e- y : e.weight > 5];					//get all nodes whose edges' weights are greater than 5.

Records:
my_field = my_record["name_of_field"];

Edges:
my_weight = edge["weight"]; //access a feature in an edge
b = "weight";				//or
my_child = edge[b];

Nodes:
my_street = node["street"];		//gets a feature of the node. Same syntax as getting a feature of an edge.

Lists:
entry = list[0];				//can be accessed by 

5.15. Dot Operator: Access fields of a record, or nodes of a graph
node = graph.nodes["Chicago"];				//access a node by its keyword
edges = graph.edges 						//what if this is an edge, not an edge descriptor?
numschools = node.schools;

Edges:
edge_rel = edge.rel; 						//to get 2--3 out of an edge.
node = edge.to;								//the node pointed to by the edge
node2 = edge.from;							//the node that extends from the edge


Nodes:
graph = node.graph;			//A node can only be in one graph at once.
//Traversing the graph from node to node
my_friends = node.friends		//Gets all nodes connected by an edge to this node in any direction.
my_friends = node.to 			//Every node connected by an edge going to the node. 
my_friends = node.from 			//Every node connected by an edge going from the node.

**danger of silently returning a list instead of a single node or edge...**

5.2. Unary Operators:
!expr  (booleans, boolean expr) Logical not. Yields the opposite value of the expression.
-expr (int, double) Numeric negation. Yields the expression multiplied by negative one.

5.3. Numeric Binary Operators
Binary operators group left to right. 

int * int 			//Integer Multiplication operator
double *. double 	//Double Multiplication operator
int / int 		//Integer Division operator
double /. double 		//Double Division operator


int + int 				//Integer Addition operator
double +. double 		//Double Addition operator
int - int 				//Integer Subtraction operator
int -. int 				//Double Subtraction operator

5.3.5 Graph, Edge, and Node Operators
graph & node Yields a graph with the node added
graph &. edge Yields a graph with the edge added (if the edge is not already in the graph)

5.4. Relational Operators
expr < expr (int, double, string), less than
expr > expr (int, double, string), greater than
expr <= expr (int, double, string), less than or equal to
expr >= expr (int, double, string), greater than or equal to
Return true if the relation is true and false otherwise

5.5. Equality Operators
expr == expr (int, double, string) returns true if the numbers are equal, and false otherwise
expr != expr (int, double, string) returns false if the numbers are equal, and true otherwise 

expr == expr (graph) returns true if both graphs contain the same nodes and edges

5.6. Logical Operators
expr && expr (boolean), returns true if both booleans or boolean expressions are true and false otherwise
expr || expr (boolean), returns true if at least one of the booleans or boolean expressions is true and false otherwise

5.7. Assignment
variable = expr, replaces the value of your variable with the value of the expr.
variable .= object, makes a copy of object and puts in variable.


Examples:
list = ["Bob", "Diane", "Agnes"];												//list
yourlist .= list;
record = {age:6, weight:15, size:{height:65, head:"big"}, children:my_list};		//record
node = {eleven:my_record};														//node
node = {7:{seen:[4,5,2]}};
node = {8:{age:5, change:"were"}};				
fields = {weight:7, capacity:5, street:"Dawson"};									//record
graph = (node, your_node, his_node, her_node, node -> your_node, his_node <- her_node, her_node -- node) with my_fields;
graph = () with {weight:1, capacity:1, street:""};
graph = () with fields;
edge_desc = node -> your_node;												//an edge descriptor
edge = node -> your_node with {weight:1, capacity:1, street:""};				//an edge
edge2 = her_node -> his_node with fields;

my_int = 3; 																			//int
my_double = 3.0;																		//double
g = (e, f, g) with {weight:1};
//where e, f, and g are edges, edge descriptors, or nodes of the same type. The field after with is the default edge record

5.7 Edge Descriptor
node -- node yields an edge-descriptor connecting both nodes. The operator can be --, ->, <-

5.8. Edge Operators
node -- node with record, yields an edge connecting both expr’s (num, char, or string), with the fields set according to the record.
node -> node with record, yields directed edge from the first expr (num, char, or string), with the fields set according to the record.
node <- node with record, yields directed edge from the second expr (num, char, or string), with the fields set according to the record.

6. Declarations
Declarations are done through initialization. Type is inferred. 

6.3 Function Declarator
The Function declarator is formatted in the following way:
	function functionName(param, param, … )

FunctionName is the identifier of the function, followed by a left parenthesis, a list of function parameters(optional), and a right parenthesis. In the function parameter list, these parameters need to be separated by commas. 

6.4 Initialization
The general format of the initialization of variables is:
	variableName = assignment expression / { list of edges or edge-relations }

	Primitives:
	variableName = value;

	Records: //Records have literal declaration:
	accio(space);		//or something
	myRecord = {field1:val1, field2:val2...};

	Nodes:
	accio(space);
	myNode = {key:myrecord};

	Edge-Descriptor:
	mydesc = node -> node;
	mydesc = node <- node;
	mydesc = node -- node;	//undirected edge is technically two edges, one in each direction, with the same record

	Edges:
	accio(space);
	myEdge = edge_desc with myrecord;
	
	Graph:	//a graph can take any number of edges and nodes or lists of edges and nodes
	accio(space);
	graph = {edge, node, … } with myrecord | {list of edges} with myrecord
	
The following examples shows the declaration and initialization of graphs and nodes:

g = (1->2,2->3,3->4) with {weight:1};
g = (2->3 with {weight:2, capacity:7}) with {weight:1, capacity:8};
//or
g = (2->3 {2,7}) with {weight:1, capacity:8};

g += u -> v; //add an edge between u and v with weight:1
g += n -- m with {weight:7}  //add an edge with a different record;
g += o -- p with {weight:7, capacity:6} //illegal! Error!
g += a;		//adds the node to the node list of g.

//what about adding something already in the graph? If it's a relation it'll stay, if it's an edge it'll throw up an error? You'll have to fetch the edge yourself and change its fields? 

6.5 Update
Edges:
	e = 2--3 with {weight:4, height:7};	//initialize
	e.rel = 4--3;						//update edges
	e.to = 5;							//e.rel = 4--5 (does it cause problems to remember which is from and which to?)
	e = e.rel {4,6};					//update the height to 7 **what about e = e.rel {record} ? Do we need a with?**
	e.height = 5;						//update the height to 5.

**we still need a way to grab all the nodes or edges that a node is connected to irrespective of the graph. **

7. Statements
	Statements executes in sequence. They do not have values and are executed for their effects. The statements in our language are classified in the following groups:
Assignment statement
	Function-call statement
	Sequence statement
	Control-Flow statement
	Loop Statement
	Jump Statement
	

7.1 Assignment Statement 
Assignment statement is used to assign identifier with the value of the expression. It is formatted in the following format:
	identifierName = expression;
This statement is commonly used for initialization of variables or expressions. 

7.2 Function-Call Statement 
The function-call statement is used when a defined function is called. It is formatted in the following format. Parameters can be any of the primitive types or objects or expressions that evaluate to those types or objects.

type functionName (parameter, parameter, ...);


7.3 Sequence Statement 
Statements can be written one after another. This is seen as the sequence statement and is formatted in the following format:
	statement; statement; statement; …


7.4 Control-Flow Statement
The control-flow statements use the expression as conditional test to decide which block of statements will get executed. They have the following formats:
if (expression) { statement(s) }
if (expression) { statement(s) } else { statement(s) }
if (expression) { statement(s) } else if (expression) { statement(s) } else { statement(s) }


7.5 Loop Statement
while loop and for loop are available in the GRAIL in the following format:

while (expression) { statement(s) }
for (initialization expression; conditional expression; execution expression ) { statement(s) }

The while loop takes one expression as the conditional expression to check if the available variables or expressions qualify, which determine if the body statement(s) will be executed or not. The for loop takes three expressions : initialization expression, conditional expression, and execution expression. The initialization expression will be executed when the for loop is initiated. The conditional expression is the test expression to check if the condition(s) is satisfied, which corresponds to if the body statement(s) will be executed. The execution expression will be executed after every time the body statement(s) is executed. 

7.6 Jump Statement
break can be used to break the first outer loop if a certain condition is reached. 
	for (expression; expression; expression) {
		…
		if (expression) {
			break;
		}
		....
	}

continue can be used to continue to the next round of the loop if a certain condition is reached. 
	while (expression) {
		…
		if (expression) {
			continue;
		}
		....
	}

8. Scope
A declared entity is a class type, member (class, field, or function) of a reference type, type parameter (of a class, function or constructor), parameter (to a function, constructor), or local variable.
Every declaration that introduces a name has a scope, which is the part of the program text within which the declared entity can be referred to by a simple name.
The scope of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name. 
A declaration is said to be in scope at a particular point in a program if and only if the declaration's scope includes that point.
The scope of a formal parameter of a function or constructor is the entire body of the function or constructor. 
The scope of a function's type parameter  is the entire declaration of the function, including the type parameter section, but excluding the function modifiers. 

9. Library Functions
9.1 Print 
Prints strings to standard output. 
	print (list of string statement)

9.2 Display
Function for displaying graphs and digraphs
	display(graph)
	display(digraph)

9.3 Dir
Function for getting the direction of an edge. Will return -1, 0, or 1 for <-, --, or ->

10. Examples
Sort a list of edges by their weight:
function sort(my_list, feature){
	sort(my_list, 0, size(my_list)-1, feature);
}
function sort(my_list, left, right, feat){
	if(left < right){
		pivot = my_list[right];
		partition = partitionIt(my_list, left, right, pivot, feat);
		sort(my_list, left, partition-1, feat);
		sort(my_list, partition+1, right, feat);
	}
	return my_list;
}
function partitionIt(my_list, left, right, pivot, feat){
	l = left;
	r = right;
	while(l < r){
		while(a[l][feat] < pivot)
			l++;
		while(r > 0 && a[r][feat] > pivot)
			r--;
		if(r <= l)
			break;
		swap(my_list, r, l);
	}
	swap(a, l, right);
	return l;
}
function swap(my_list, left, right){
	temp = my_list[left];
	my_list[left] = my_list[right];
	my_list[right] = temp;
}
function main(){
	f = {"Franklin":{}};
	e = {"Englewood":{region: "24j2ioj"}};
	d = {"Dawson":{region: "523io9852"}};
	mygraph = {e, f, g, f->g, g<-f, f--e} with {weight:1};			//default fields weight:1
	mygraph[f->g].weight = 3;
	mygraph[g<-f].weight = 8;

	mylist = mygraph[x <> y :];
	mylist = sort(my_list, "weight");
}

//Walking through the graph in order? Iterating through all edges, all nodes? Ordering nodes, edges
edges = graph[x <> y :]	//grab all edges of any type in the graph and place in a list.

The following program implements Djikstra’s Algorithm for finding a shortest path.

list getclosestpaths(graph g, num s){

g.sort(weight, asc);
list dist = [size(g)]; 
list prev= [size(g)];
list visited = [size(g)];

num inf = Grail.Math.INF;

for(num i = 0; i < size(dist); i+=1){
dist[i] = inf;
visited[i] = false;
}
dist[s] = 0;

for(num i = 0; i < size(g); i+=1){
next = closestNode(dist, visited);
visited[next] = true;
neighbors = g[x --> y : x == next]; //Get all nodes from x

for(num j = 0; j < size(neighbors); j+=1){
num n = neighbors[j];
num d = neighbors[j].weight + dist[next];

if(dist[n] > d){
dist[n] = d;
prev[n] = next;
}
}
}
return pred;
}

num closestNode(list dist, list visited){
num d = Grail.Math.INF;
num n;
for(num i = 0; i < size(dist); i++){
if(v[i] == false && dist[i] < d){
n = i;
d = dist[i];
}
}
return n;
}

//initialize a graph, add a node and an edge, and run closest paths algorithm

graph g = {1->2,2->3,3->4};
g* += 5;
g += 4->5;

list allPaths = getClosestPaths(g,1);

11. Recapitulation
GRAIL is possessed of several types, denoted by keywords such as num and 


